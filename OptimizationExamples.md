For each optimization we implemented in [IonMonkey](https://wiki.mozilla.org/Platform/Features/IonMonkey), we have made available a [JavaScript](http://en.wikipedia.org/wiki/JavaScript) source file which shows nicely the effects of the optimization and two control flow graphs - one before the optimization and the other, after it. A brief description also accompanies each optimization.

You can execute the file using the command shown in each description section. The control flow graphs can be generated with Sean Stangl's [iongraph](https://github.com/sstangl/iongraph).

| **JavaScript** | **Before** | **After** | **Description** |
|:---------------|:-----------|:----------|:----------------|
| [![](http://i.imgur.com/L9rTW.gif)](http://jit-value-specialization.googlecode.com/hg/examples/ps.js) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/ps-before.png) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/ps-after.png) | **Value Specialization**: Value specialization consists in replacing the arguments passed to a function by the values associated with these arguments at the time the function is called. Our optimizer performs this replacement while the MIR control flow graph is built; therefore, it imposes no overhead on the compiler. That is, instead of creating a virtual name for each parameter in the graph, we create a constant with that parameter’s runtime value. We have immediate access to the value of each parameter, as it is stored in the interpreter’s stack. There are two types of inputs that we “constify”: those in the function entry block, and those in the OSR block. Performing the replacement during the MIR construction means, there's really no "Before" graph, so, in this case, the "Before" graph is from an execution for which value specialization was disabled. Run with: `./js --ion-ps --ion-cp ps.js` |
| [![](http://i.imgur.com/L9rTW.gif)](http://jit-value-specialization.googlecode.com/hg/examples/cp.js) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/cp-before.png) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/cp-after.png) | **[Constant Propagation](http://en.wikipedia.org/wiki/Constant_propagation)**: Constant propagation consists in replacing any instruction operand for which only one value is possible with a constant. When this happens, some instructions may end up with all arguments being constants. Such instructions can be evaluated at compile-time and their uses can be replaced with the result of the evaluation. This act of eliminating an instruction that only operates on constants is called instruction folding. Run with: `./js --ion-ps --ion-cp cp.js` |
| [![](http://i.imgur.com/L9rTW.gif)](http://jit-value-specialization.googlecode.com/hg/examples/dcec.js) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/dcec-before.png) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/dcec-after.png) | **[Dead Code Elimination](http://en.wikipedia.org/wiki/Dead_code_elimination)**: Dead-code elimination removes instructions that we prove that cannot be reached by the program flow. We run it after constant propagation, in order to give instruction folding the chance to transform conditional branches into simple boolean values. Whenever this extensive folding is possible, the outcome of the conditional branch can be predicted at compile-time; thus, we can safely remove the branch instruction and, possibly, blocks of unreachable code. Run with: `./js --ion-ps --ion-cp --ion-dcec dcec.js` |
| [![](http://i.imgur.com/L9rTW.gif)](http://jit-value-specialization.googlecode.com/hg/examples/bce.js) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/bce-before.png) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/bce-after.png) | **[Bounds Check Elimination](http://en.wikipedia.org/wiki/Bounds-checking_elimination)**: JavaScript is a type safe language, which means that any value can only be used according to the contract specified by its runtime type. As a consequence of this type safety, array accesses in JavaScript are bound checked. Accesses outside the bounds of the array return the undefined constant, which is the only element in the `undefined` data type. Bound checking an index is a relatively expensive operation, because, at the native code level it requires loading the array length property, and demands two conditional tests. The knowledge of function inputs allows us to eliminate some simple bound checks. Run with: `./js --ion-ps --ion-cp --ion-bce bce.js` |
| [![](http://i.imgur.com/L9rTW.gif)](http://jit-value-specialization.googlecode.com/hg/examples/linv.js) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/linv-before.png) | ![![](http://i.imgur.com/P3cr0.png)](http://jit-value-specialization.googlecode.com/hg/examples/linv-after.png) | **[Loop Inversion](http://en.wikipedia.org/wiki/Loop_inversion)**: Loop inversion is a classic compiler optimization that consists in replacing a while loop by a repeat loop. The main benefit of this transformation is to replace a conditional and an unconditional jump inside a loop by just a conditional loop at its end. Usually, loop inversion inserts a wrapping conditional around the repeat loop, to preserve the semantics of the original program. This conditional, only traversed once by the program flow, ensures that the body of the repeat loop will not be executed if the corresponding while loop iterates zero times. Run with: `./js --ion-ps --ion-cp --ion-linv cp.js` |